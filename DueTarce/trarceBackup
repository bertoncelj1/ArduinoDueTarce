#include <DueTimer.h>
#include <knjiznica.h>

#include <LiquidCrystal.h>
#include <senzorjiDueTarce.h>

//#include <EEPROM.h>


s_ekran mainMenu = //MENI_GLAVNI
{
  "Glavni meni",
  //tipke:
  //gor dol levo, desno, select
  0, FUN_TIPKE, DEC_IZBRAN, INC_IZBRAN, 0,
  4, 0,
  "igraj !",      MENI_IGRAJ,
  "nastavitve",   MENI_NASTAVITVE,
  "info",         0,
  "random :)",    0,
};

s_ekran nastavitveMenu = //MENI_NASTAVITVE
{
  "Nastavitve",
  //gor dol levo, desno, select
  MENI_GLAVNI, FUN_TIPKE, DEC_IZBRAN, INC_IZBRAN, 0,
  2, 0,
  "sensorji",       NAST_SENZORJI,
  "st. tarc",       NAST_ST_TARC,
};

s_ekranNastavitve stTarcNast =  //NAST_ST_TARC
{
  "Nast. st. tarc",
  //gor dol levo, desno, select
  MENI_NASTAVITVE, NAST_EDIT, DEC_IZBRAN, INC_IZBRAN, 0,
  //st parametrov, trenutno izbran, focus
  1, 0, OFF,
  //opis,    min   max,  def,  korak, index
  "st. tarc:", 1, 9, 9, 1, MEM_ST_TARC
};

s_ekranNastavitve senzorjiNast =  //NAST_SENZORJI
{
  "Nast. senzo",
  //gor dol levo, desno, select
  MENI_NASTAVITVE, NAST_EDIT, DEC_IZBRAN, INC_IZBRAN, 0,
  //st parametrov, trenutno izbran, focus
  2, 0, OFF,
  //opis,    min   max,  def,  korak, index
  "obcut.:", 1000, 2000, 1500, 100, MEM_OBCUT,
  "zamik:",  100,  1000, 400,  100, MEM_ZAMIK,
};

s_ekranNastavitveEdit editNast =  //NAST_EDIT
{
  0,
  //gor dol levo, desno, select
  NAST_EDIT_FINISH, 0, NAST_EDIT_DEC, NAST_EDIT_INC, 0,
  //return state
  0
};

s_ekran igrajMenu = //MENI_IGRAJ
{
  "Izberi program:",
  //gor dol levo, desno, select
  MENI_GLAVNI, FUN_TIPKE, DEC_IZBRAN, INC_IZBRAN, 0,
  5, 0,
  "program 1",        MENI_PROG1,
  "program 2",        MENI_PROG2,
  "program 3",        MENI_PROG3,
  "program 4",        MENI_PROG4,
  "program 5",        MENI_PROG5
};

s_ekran prog1Menu = //MENI_PROG1
{
  "Program 1:",
  //gor dol levo, desno, select
  MENI_IGRAJ, FUN_TIPKE, DEC_IZBRAN, INC_IZBRAN, 0,
  2, 0,
  "zacni z igro",        PROGRAM_1,
  "nastavitve",        	 NAST_PROG1,
};

s_ekranNastavitve prog1Nast =  //NAST_PROG1
{
  "prog1 nastavitve",
  //gor dol levo, desno, select
  MENI_PROG1, NAST_EDIT, NAST_DEC_IZBRAN, NAST_INC_IZBRAN, 0,
  //st parametrov, trenutno izbran, focus
  1, 0, OFF,
  //opis,    min   max,  def,  korak, index
  "cas:",  10,  200, 60,  10, MEM_PROG1_CAS,
  //"hitrost:",  100,  1000, 500,  50

};

s_ekran prog2Menu = //MENI_PROG2
{
  "Program 2:",
  //gor dol levo, desno, select
  MENI_IGRAJ, FUN_TIPKE, DEC_IZBRAN, INC_IZBRAN, 0,
  2, 0,
  "zacni z igro",        PROGRAM_2,
  "nastavitve",        	 NAST_PROG1,
};

s_ekranNastavitve prog2Nast =  //NAST_PROG2
{
  "prog2 nastavitve",
  //gor dol levo, desno, select
  MENI_PROG2, NAST_EDIT, NAST_DEC_IZBRAN, NAST_INC_IZBRAN, 0,
  //st parametrov, trenutno izbran, focus
  2, 0, OFF,
  //opis,    min   max,  def,  korak, index
  "tezavnost:", 1, 5, 3, 1, MEM_PROG2_TEZ,
  "cas:",  10,  200, 60,  10, MEM_PROG2_CAS,
  //"hitrost:",  100,  1000, 500,  50

};

s_ekran prog3Menu = //MENI_PROG3
{
  "Program 3:",
  //gor dol levo, desno, select
  MENI_IGRAJ, FUN_TIPKE, DEC_IZBRAN, INC_IZBRAN, 0,
  2, 0,
  "zacni z igro",        PROGRAM_3,
  "nastavitve",        	 NAST_PROG1,
};

s_ekranNastavitve prog3Nast =  //NAST_PROG3
{
  "prog3 nastavitve",
  //gor dol levo, desno, select
  MENI_PROG3, NAST_EDIT, NAST_DEC_IZBRAN, NAST_INC_IZBRAN, 0,
  //st parametrov, trenutno izbran, focus
  2, 0, OFF,
  //opis,    min   max,  def,  korak, index
  "tezavnost:", 1, 5, 3, 1, MEM_PROG3_TEZ,
  "cas:",  10,  200, 60,  10, MEM_PROG3_CAS,
  //"hitrost:",  100,  1000, 500,  50

};

s_ekran prog4Menu = //MENI_PROG4
{
  "Program 4:",
  //gor dol levo, desno, select
  MENI_IGRAJ, FUN_TIPKE, DEC_IZBRAN, INC_IZBRAN, 0,
  2, 0,
  "zacni z igro",        PROGRAM_4,
  "nastavitve",        	 NAST_PROG1,
};

s_ekranNastavitve prog4Nast =  //NAST_PROG4
{
  "prog4 nastavitve",
  //gor dol levo, desno, select
  MENI_PROG4, NAST_EDIT, NAST_DEC_IZBRAN, NAST_INC_IZBRAN, 0,
  //st parametrov, trenutno izbran, focus
  2, 0, OFF,
  //opis,    min   max,  def,  korak, index
  "tezavnost:", 1, 5, 3, 1, MEM_PROG4_TEZ,
  "cas:",  10,  200, 60,  10, MEM_PROG4_CAS,
  //"hitrost:",  100,  1000, 500,  50

};

s_ekran prog5Menu = //MENI_PROG5
{
  "Program 5:",
  //gor dol levo, desno, select
  MENI_IGRAJ, FUN_TIPKE, DEC_IZBRAN, INC_IZBRAN, 0,
  2, 0,
  "zacni z igro",        PROGRAM_5,
  "nastavitve",        	 NAST_PROG1,
};

s_ekranNastavitve prog5Nast =  //NAST_PROG5
{
  "prog5 nastavitve",
  //gor dol levo, desno, select
  MENI_PROG5, NAST_EDIT, NAST_DEC_IZBRAN, NAST_INC_IZBRAN, 0,
  //st parametrov, trenutno izbran, focus
  2, 0, OFF,
  //opis,    min   max,  def,  korak, index
  "tezavnost:", 1, 5, 3, 1, MEM_PROG5_TEZ,
  "cas:",  10,  200, 60,  10, MEM_PROG5_CAS,
  //"hitrost:",  100,  1000, 500,  50

};


s_ekranProgram program1 =          // PROGRAM_1
{
  0,
  //gor dol levo, desno, select
  MENI_PROG1, 0, 0, 0, 0,
};

s_ekranProgram program2 =         // PROGRAM_2
{
  0,
  //gor dol levo, desno, select
  MENI_PROG2, 0, 0, 0, 0,
};

s_ekranProgram program3 =         // PROGRAM_3
{
  0,
  //gor dol levo, desno, select
  MENI_PROG3, 0, 0, 0, 0,
};

s_ekranProgram program4 =        // PROGRAM_4
{
  0,
  //gor dol levo, desno, select
  MENI_PROG3, 0, 0, 0, 0,
};

s_ekranProgram program5 =        // PROGRAM_5
{
  0,
  //gor dol levo, desno, select
  MENI_PROG3, 0, 0, 0, 0,
};



// def vrednosti odstevalnika
s_odstevajInit odstevalnik = {
  //state, millis, stOdstevanj, returnState
  0, 0, 5, 255
};

s_drawTockeInit risalnikTock = {
  //nacin, cas, hitrostScrolla
  DRAW_TOCKE_KLIK, 0, 100, 0
};




// initialize the library with the numbers of the interface pins
LiquidCrystal lcd(12, 11, 5, 4, 3, 2);
int sensorTipke = A0;  //pin na katerega so priklopjene tipke
int tipke[5];          //kolikokrat je bila tipka pritisnjena
int i;
int piskac = OFF;
int stoparica = OFF;
int stevec = 0;
int piskacCnt = 0;
int gumbi[5];
int adc_key_in;
int funInt = 1;
uint8_t state;
uint8_t puscice = 0; // ali so narisane puščice ?
uint32_t vsiEkrani[MAX_EKRANOV];
uint32_t spomin[MAX_SPOMIN];
long zacetniCas = 0;
long zacetniCas2 = 0;
char *(besedila)[3] = {
  "Igra", "Start ", "Info"
};
char izpis[16] = {ZNAK_LEVO, ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ZNAK_DESNO};
int8_t programState = -1;

void setup() {
  getSpomin(0);
  Serial.begin(9600);
  Serial.println("Program Start");
  lcd.begin(16, 2);
  initTipke();
  initPiskac();
  initSenzorji(spomin[MEM_ST_TARC], spomin[MEM_ZAMIK]);
  initEkrane();

  char outStr[17];
  char cifra[3];

  switch (risalnikTock.nacin) {
    case DRAW_TOCKE_SCROLL:

      break;

    case DRAW_TOCKE_KLIK:
      int i = 0;
      outStr[i++] = '<';//ZNAK_LEVO;
      outStr[i++] = '_';

      int krog = 0;
      while (krog < 2) { // to je glih tok da nardi dva kroga
        outStr[i++] = 't';
        outStr[i++] = risalnikTock.pozicija % stTarc + 0x30;
        outStr[i++] = ':';

        itoa(tocke[i], cifra, 10);
        outStr[i++] = cifra[0];
        outStr[i++] = cifra[1];
        if (getDecLength(tocke[risalnikTock.pozicija % stTarc]) > 2) {
          outStr[i++] = cifra[2];
        }

        outStr[i++] = ' ';
        krog ++;
      }

      outStr[14] = '_';
      outStr[15] = '>';//ZNAK_DESNO;
      outStr[16] = 0;



      break;
  }

  char *to = &outStr[0];
  
  //lcd.print(to);
  i = 0;
  for (; i < 17; i++) {
    Serial.write(*to);
    to++;
    //Serial.print(" ");
  }
  Serial.println("L");

  to = drawTocke();
  //lcd.print(to);
  i = 0;
  for (; i < 17; i++) {
    Serial.write(*to);
    to++;
    //Serial.print(" ");
  }
  Serial.println("L");

  //check(NAST_PROG1);


  state = MENI_GLAVNI;
}

char* drawTocke() {
  char outStr[17];
  char cifra[3];

  switch (risalnikTock.nacin) {
    case DRAW_TOCKE_SCROLL:

      break;

    case DRAW_TOCKE_KLIK:
      int i = 0;
      outStr[i++] = '<';//ZNAK_LEVO;
      outStr[i++] = '_';

      int krog = 0;
      while (krog < 2) { // to je glih tok da nardi dva kroga
        outStr[i++] = 't';
        outStr[i++] = risalnikTock.pozicija % stTarc + 0x30;
        outStr[i++] = ':';

        itoa(tocke[i], cifra, 10);
        outStr[i++] = cifra[0];
        outStr[i++] = cifra[1];
        if (getDecLength(tocke[risalnikTock.pozicija % stTarc]) > 2) {
          outStr[i++] = cifra[2];
        }

        outStr[i++] = ' ';
        krog ++;
      }

      outStr[14] = '_';
      outStr[15] = '>';//ZNAK_DESNO;
      outStr[16] = 0;



      break;
  }


  /*i = 0;
  for(;i<17;i++){
    Serial.write(*to);
    to++;
    //Serial.print(" ");
  }
  Serial.println("L");
  */

  return &outStr[0];
}

void check(int st) {
  Serial.print(((s_ekran*)vsiEkrani[st])->tipke[btnRIGHT]);
  Serial.print(" ");
  Serial.print(((s_ekran*)vsiEkrani[st])->tipke[btnUP]);
  Serial.print(" ");
  Serial.print(((s_ekran*)vsiEkrani[st])->tipke[btnDOWN]);
  Serial.print(" ");
  Serial.print(((s_ekran*)vsiEkrani[st])->tipke[btnLEFT]);
  Serial.print(" ");
  Serial.println(((s_ekran*)vsiEkrani[st])->tipke[btnSELECT]);
}

int nonStop = 0; //uporabla se da skoz krozi skoz glavno State Masino 0-OFF, 1-ON
int prevState;
void loop() {

  //Serial.println(state);
  switch (state) {
    case MENI_GLAVNI:
      drawScreen();
      break;

    case MENI_IGRAJ:
      drawScreen();
      break;

    case MENI_NASTAVITVE:
      drawScreen();
      break;

    case MENI_PROG1:
    case MENI_PROG2:
    case MENI_PROG3:
    case MENI_PROG4:
    case MENI_PROG5:
      drawScreen();
      break;

    case NAST_PROG1:
    case NAST_PROG2:
    case NAST_PROG3:
    case NAST_PROG4:
    case NAST_PROG5:
    case NAST_ST_TARC:
    case NAST_SENZORJI:
      drawScreenNast();
      break;

    case NAST_EDIT:
      drawScreenEdit();
      break;

    case PROGRAM_1:
      programFSM1();
      break;

    case ODSTEVAJ:
      odstevaj();
      break;

    default:
      //ce ne dobi nc pametnga se vrne na prvotno stanje
      Serial.println("def");
      state = prevState;
      break;

  }

  prevState = state;
  while (!preveriTipke() && !nonStop);

}
//char outStr[16];
void programFSM1() {
  switch (programState) {
    case -1:
      //skonfigurira odstevalnik
      odstevalnik.state = 1;
      odstevalnik.stOdstevanj = 1;
      odstevalnik.mills = 0;
      odstevalnik.returnState  = state;
      state = ODSTEVAJ;
      nonStop = 1;
      programState = 0;
      //odstevalnik premakne programState naprej na 1
      break;

    case 1:
      programState = 2;

      //resetira vse tocke in pokaze vse tarce
      resetScore();
      aktivirajVse();

      //ustavi STM da ne loopa
      nonStop = 0;


      lcd.clear();
      lcd.setCursor(0, 0);
      lcd.print("Tocke:");

      //izrise 2 vrstico
      lcd.setCursor(0, 1);
      //init risalnik tock struct, in izpise tocke
      risalnikTock.nacin = DRAW_TOCKE_KLIK;
      risalnikTock.pozicija = 0;

      char *to = drawTocke();
      //lcd.print(to);
      i = 0;
      for (; i < 17; i++) {
        Serial.write(*to);
        to++;
        //Serial.print(" ");
      }
      Serial.println("L");
      Serial.println("End");
      //lcd.printIn(scoreCel,16);
      zacetniCas = millis();
      break;


  }
}
void odstevaj() {
  //sPrint("ost State:", odstevalnik.state);
  switch (odstevalnik.state) {
    case 1:
      char outStr[16];
      lcd.setCursor(0, 0);
      lcd.print("Igra se zacne v");
      char cifra[2];
      piskac = OFF;
      odstevalnik.state = 2;
      odstevalnik.mills = 0;

    case 2:
      if (millis() - odstevalnik.mills > 960) {
        odstevalnik.mills = millis();
        if (odstevalnik.stOdstevanj-- == 0) {
          odstevalnik.state = 3;
          break;
        }
        lcd.setCursor(0, 1);
        itoa(odstevalnik.stOdstevanj + 1, cifra, 10);
        lcd.print(pretvoriBesedilo(outStr, cifra, NASLOV));
        piskacOn(3, ZVOK_LOW);
      }
      break;

    case 3:
      lcd.setCursor(0, 1);
      lcd.print(pretvoriBesedilo(outStr, "! GO !", NASLOV));
      piskacOn(10, ZVOK_MAX);
      if (millis() - odstevalnik.mills > 100) {
        state = odstevalnik.returnState;
        sPrint("ret State:", state);
        programState = 1;
      }
      break;
  }
}

void piskacOn(int cas, int zvok) {
  if (piskac == OFF) {
    piskacCnt = cas;
    digitalWrite(PISKAC_PIN, HIGH);
  }
  piskac = ON;
}

void piskacCount() {
  if (piskac == ON) {
    if (piskacCnt == 0) {
      //Timer1.detachInterrupt();
      digitalWrite(PISKAC_PIN, LOW);
      piskac = OFF;
    }
    else piskacCnt --;
  }
}

void drawScreen() {
  char outStr[16];

  // izpiše naslov
  lcd.setCursor(0, 0); // postav ga na sredino //TODO: IZRUSI SAMO TAKRAT KO GA se spremeni !!
  lcd.print(pretvoriBesedilo(&outStr[0], ((s_ekran*)vsiEkrani[state])->naslov, NASLOV));

  //izpiše spodnje besedilo
  lcd.setCursor(0, 1);
  lcd.print(pretvoriBesedilo(&outStr[0], ((s_ekran*)vsiEkrani[state])->elementi[((s_ekran*)vsiEkrani[state])->trenutnoIzbran].besedilo, BESEDILO));
  programState = -1; //TODO premakn to na bolsi mest
}

void drawScreenNast() {
  char outStr[16];
  char vrednostStr[4];

  // izpiše naslov
  lcd.setCursor(0, 0); // postav ga na sredino //TODO: IZRUSI SAMO TAKRAT KO GA se spremeni !!
  lcd.print(pretvoriBesedilo(&outStr[0], ((s_ekranNastavitve*)vsiEkrani[state])->naslov, NASLOV));

  //izpiše spodnje besedilo
  lcd.setCursor(0, 1);
  //if(((s_ekranNastavitve*)vsiEkrani[state])->focus == OFF){
  uint8_t treIzbran = ((s_ekranNastavitve*)vsiEkrani[state])->trenutnoIzbran;
  char *opis = ((s_ekranNastavitve*)vsiEkrani[state])->parameter[treIzbran].opis;
  uint32_t vrednost = ((s_ekranNastavitve*)vsiEkrani[state])->parameter[treIzbran].vrednost;
  int b = 0; //<-- stevec ki se premika po poljih

  //postavi puscice
  outStr[b++] = ZNAK_LEVO;
  outStr[15] = ZNAK_DESNO;
  uint8_t dolzina = (getDecLength(vrednost) + getLngth(opis) + 1);
  while (b < 8 - (dolzina - dolzina / 2)) {
    outStr[b++] = ' ';
  }


  //zapise opis parametra

  // postavi na sredino
  while (*opis != 0) {
    outStr[b++] = *opis;
    opis ++;
  }
  outStr[b++] = ' ';
  //zapise vrednost
  itoa(vrednost, vrednostStr, 10);
  //itoa(get_free_memory(),vrednostStr,10);
  for (i = 0; i < getDecLength(vrednost); b++, i++) {
    outStr[b] = vrednostStr[i];
  }
  //zapise presledke do konca
  while (b < 15) {
    outStr[b++] = ' ';
  }

  lcd.print(outStr);
  //}else{
  //}
}


void drawScreenEdit() {
  //naslovne vrstico pustimo pri miru
  //spreminjamo samo ta drugo
  char outStr[16];
  char vrednostStr[4]; // charr arr v katerga zapisemo vrednost
  int b = 0;               // stevec ki se premika po poljih naprej

  lcd.setCursor(0, 1);
  char *opis = d_parameter.opis;

  uint8_t dolzina = (getDecLength(d_parameter.vrednost) + getLngth(opis) + 5);
  //zapise opis
  while (b < 8 - (dolzina - dolzina / 2)) {
    outStr[b++] = ' ';
  }

  while (*opis != 0) {
    outStr[b++] = *opis;
    opis ++;
  }

  //postavi puscico levo
  outStr[b++] = ' ';
  outStr[b++] = ZNAK_LEVO;
  outStr[b++] = ' ';


  //zapise vrednost
  itoa(d_parameter.vrednost, vrednostStr, 10);
  for (i = 0; i < getDecLength(d_parameter.vrednost); b++, i++) {
    outStr[b] = vrednostStr[i];
  }

  outStr[b++] = ' ';
  outStr[b++] = ZNAK_DESNO;
  outStr[b++] = ' ';

  //zapise presledke do konca
  while (b < 16) {
    outStr[b++] = ' ';
  }


  lcd.print(outStr);
}

uint8_t preveriTipke() {
  if (get_LCD_button(btnUP)) {
    //Serial.println(((s_ekran*)vsiEkrani[state])->tipke[btnUP]);
    return izvediUkaz(((s_ekran*)vsiEkrani[state])->tipke[btnUP]);
  }
  else if (get_LCD_button(btnDOWN)) {
    //Serial.println(((s_ekran*)vsiEkrani[state])->tipke[btnDOWN]);
    return izvediUkaz(((s_ekran*)vsiEkrani[state])->tipke[btnDOWN]);
  }
  else if (get_LCD_button(btnRIGHT)) {
    //Serial.println("RIGHT");
    return izvediUkaz(((s_ekran*)vsiEkrani[state])->tipke[btnRIGHT]);
  }
  else if (get_LCD_button(btnLEFT)) {
    //Serial.println("LEFT");
    return izvediUkaz(((s_ekran*)vsiEkrani[state])->tipke[btnLEFT]);
  } else if (get_LCD_button(btnSELECT)) {
    //Serial.println("SELECT");
    return izvediUkaz(((s_ekran*)vsiEkrani[state])->tipke[btnSELECT]);
  }
  //else if(get_LCD_button(btnUP));
  return 0;
}
int defVrednost;
uint8_t izvediUkaz(uint8_t ukaz) {
  if (ukaz == 0)return 0;
  if (ukaz < MAX_EKRANOV) {
    state = ukaz;
    return 1;
  }
  switch (ukaz) {
    case FUN_TIPKE:
      //Serial.println(((s_ekran*)vsiEkrani[state])->elementi[((s_ekran*)vsiEkrani[state])->trenutnoIzbran].funkcija);
      return izvediUkaz(((s_ekran*)vsiEkrani[state])->elementi[((s_ekran*)vsiEkrani[state])->trenutnoIzbran].funkcija);

    case INC_IZBRAN:
      if (((s_ekran*)vsiEkrani[state])->trenutnoIzbran < ((s_ekran*)vsiEkrani[state])->st_elementov - 1) {
        ((s_ekran*)vsiEkrani[state])->trenutnoIzbran ++;
      } else {
        ((s_ekran*)vsiEkrani[state])->trenutnoIzbran = 0;
      }
      return 1;

    case DEC_IZBRAN:
      if (((s_ekran*)vsiEkrani[state])->trenutnoIzbran > 0) {
        ((s_ekran*)vsiEkrani[state])->trenutnoIzbran --;
      } else {
        ((s_ekran*)vsiEkrani[state])->trenutnoIzbran = ((s_ekran*)vsiEkrani[state])->st_elementov - 1;
      }
      return 1;


    case NAST_INC_IZBRAN:
      if (((s_ekranNastavitve*)vsiEkrani[state])->trenutnoIzbran < ((s_ekranNastavitve*)vsiEkrani[state])->stParametrov - 1) {
        ((s_ekranNastavitve*)vsiEkrani[state])->trenutnoIzbran ++;
      } else {
        ((s_ekranNastavitve*)vsiEkrani[state])->trenutnoIzbran = 0;
      }
      return 1;

    case NAST_DEC_IZBRAN:
      if (((s_ekranNastavitve*)vsiEkrani[state])->trenutnoIzbran > 0) {
        ((s_ekranNastavitve*)vsiEkrani[state])->trenutnoIzbran --;
      } else {
        ((s_ekranNastavitve*)vsiEkrani[state])->trenutnoIzbran = ((s_ekranNastavitve*)vsiEkrani[state])->stParametrov - 1;
      }
      return 1;


    case NAST_EDIT_DEC:
      d_parameter.vrednost -= d_parameter.korak;
      if (d_parameter.vrednost < d_parameter.min) {
        d_parameter.vrednost = d_parameter.min;
      }
      return 1;

    case NAST_EDIT_INC:

      d_parameter.vrednost += d_parameter.korak;
      if (d_parameter.vrednost > d_parameter.max) {
        d_parameter.vrednost = d_parameter.max;
      }

      return 1;

    case NAST_EDIT:
      //prebere vresnost iz spomina
      defVrednost = d_parameter.vrednost;
      sPrint("defV:", defVrednost);
      d_parameter.vrednost = spomin[d_parameter.index];
      sPrint("izSpomina:", spomin[d_parameter.index]);
      if ( d_parameter.max < d_parameter.vrednost || d_parameter.vrednost > d_parameter.min) {
        d_parameter.vrednost = defVrednost;
      }

      // zapovne si state da ve kere podatke ureja
      d_retState = state;

      state = NAST_EDIT;
      Serial.println("We are in");
      return 1;

    case NAST_EDIT_FINISH:
      //zapise vrednost nazaj v spomin
      spomin[d_parameter.index] = d_parameter.vrednost;
      //EEPROM.write(d_parameter.index, d_parameter.vrednost); TODO: urihtej ta spomi!
      sPrint("koncna:", spomin[d_parameter.index]);
      state = d_retState;
      return 1;


  }

}

void sPrint(char* c, int a) {
  Serial.print(c);
  Serial.println(a);
}
void getSpomin(int a) {

  //nafila ceu spomin iz EEPROM-a
  for (i = 0; i < ST_SPOMINA; i++) {
    spomin[i] = -1;//EEPROM.read(i);
  }
}

void initEkrane() {
  vsiEkrani[NAST_EDIT] =         (uint32_t)(&editNast);

  vsiEkrani[MENI_GLAVNI] =       (uint32_t)(&mainMenu);
  vsiEkrani[MENI_IGRAJ] =        (uint32_t)(&igrajMenu);
  vsiEkrani[MENI_NASTAVITVE] =   (uint32_t)(&nastavitveMenu);

  vsiEkrani[NAST_ST_TARC] =      (uint32_t)(&stTarcNast);
  vsiEkrani[NAST_SENZORJI] =     (uint32_t)(&senzorjiNast);


  vsiEkrani[MENI_PROG1] =   	 (uint32_t)(&prog1Menu);
  vsiEkrani[MENI_PROG2] =   	 (uint32_t)(&prog2Menu);
  vsiEkrani[MENI_PROG3] =   	 (uint32_t)(&prog3Menu);
  vsiEkrani[MENI_PROG4] =   	 (uint32_t)(&prog4Menu);
  vsiEkrani[MENI_PROG5] =   	 (uint32_t)(&prog5Menu);

  vsiEkrani[PROGRAM_1] =   	 (uint32_t)(&program1);
  vsiEkrani[PROGRAM_2] =   	 (uint32_t)(&program2);
  vsiEkrani[PROGRAM_3] =   	 (uint32_t)(&program3);
  vsiEkrani[PROGRAM_4] =   	 (uint32_t)(&program4);
  vsiEkrani[PROGRAM_5] =   	 (uint32_t)(&program5);

  vsiEkrani[NAST_PROG1] =   	 (uint32_t)(&prog1Nast);
  vsiEkrani[NAST_PROG2] =   	 (uint32_t)(&prog2Nast);
  vsiEkrani[NAST_PROG3] =   	 (uint32_t)(&prog3Nast);
  vsiEkrani[NAST_PROG4] =   	 (uint32_t)(&prog4Nast);
  vsiEkrani[NAST_PROG5] =   	 (uint32_t)(&prog5Nast);


}

void initTipke() {
  Timer3.attachInterrupt(checkTipke).start(10000); // Every 10ms //za tipke
  pinMode(sensorTipke, INPUT);
}

void initPiskac() {
  Timer4.attachInterrupt(piskacCount).start(100000); // Every 100ms //za piskac
  pinMode(PISKAC_PIN, OUTPUT);
  digitalWrite(PISKAC_PIN, LOW);
}

long tipkeDebounceTimer[5];
//vrednosti ko so pritisnjene posamezne tipke
//1023, 990, 958, 872, 757
int tipkeVrednost[] = {1024, 1002, 970, 903, 800, 700};
int debounceDelay = 10;

#define TIPKA_DOWN     12
#define TIPKA_UP       123

void checkTipke() {
  int i;

  //prebere vrednost na pinu
  int reading = analogRead(sensorTipke);

  //glede na to vrednost se odloči katera tipka je bila pritisnjena
  if (reading > 1024)return;
  for (i = 0; i < 5; i++) {
    if (tipkeVrednost[i] > reading && reading > tipkeVrednost[i + 1]) {
      if (tipkeDebounceTimer[i] ==  TIPKA_UP) {
        tipkeDebounceTimer[i] = millis();
      }
      if (tipkeDebounceTimer[i] ==  TIPKA_DOWN) continue;
      if (millis() - tipkeDebounceTimer[i] > debounceDelay) {
        tipke[i]++;
        tipkeDebounceTimer[i] = TIPKA_DOWN;
      }
    } else {
      tipkeDebounceTimer[i] = TIPKA_UP;
    }
  }
}


//prebere tipko
int get_LCD_button(int tipka) {
  if (tipke[tipka]) {
    //Serial.println(tipkeArr[tipka]);
    tipke[tipka]--;
    return 1;
  }
  return 0;
}





//pretvori string v 16 dolg niz znakov ki je primeren za izpis
char* pretvoriBesedilo(char* out, char *str, int tip) {
  int dolzina = getLngth(str);
  int dolOuta = 16;                   // dolžina izhodnega stringa
  int i = 0;                          //števec
  if (tip == BESEDILO) {
    if (dolzina > 14)dolzina = 14;
    out[i++] = ZNAK_LEVO;                 // na provo mesto zališe puščico levo
    dolOuta = 15;                   // skrajša dolžino izhodnega striga da ne povoz desne puščice
    out[15] = ZNAK_DESNO;                  // na zadnje mesto zapie puščico desno
  } else {
    if (dolzina > 16)dolzina = 16;
  }

  int pozStr = 8 - dolzina / 2;    // pozicija stringa
  if (dolzina & 0x1)pozStr --;     // če ni deljiv z 2 ga premakne v levo

  while (i < pozStr) {
    out[i++] = ' ';             //zapiše presledke pred stringom
  }
  while (i < pozStr + dolzina) {
    out[i++] = str[i - pozStr - 1]; //zapiše string
  }
  while (i < dolOuta) {
    out[i++] = ' ';             //zapiše prtesledke po besedilu
  }
  out[16] = 0;                    // na konec stringa doda nulo
  return &out[0];
}
// vrne dolžino stringa če ima na koncu 0
int getLngth(char * c) {
  int dolzina = 0;
  while (*c++ != 0)dolzina ++;
  return dolzina;
}

int getDecLength(long n) {
  if (n < 100000)
  {
    // 5 or less
    if (n < 100)
    {
      // 1 or 2
      if (n < 10)
        return 1;
      else
        return 2;
    }
    else
    {
      // 3 or 4 or 5
      if (n < 1000)
        return 3;
      else
      {
        // 4 or 5
        if (n < 10000)
          return 4;
        else
          return 5;
      }
    }
  }
  else
  {
    // 6 or more
    if (n < 10000000)
    {
      // 6 or 7
      if (n < 1000000)
        return 6;
      else
        return 7;
    }
    else
    {
      // 8 to 10
      if (n < 100000000)
        return 8;
      else
      {
        // 9 or 10
        if (n < 1000000000)
          return 9;
        else
          return 10;
      }
    }
  }
}



